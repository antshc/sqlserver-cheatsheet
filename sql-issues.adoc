= SQL Query Performance Issues â€“ Master List

== ğŸ“¦ Insufficient or Poor Indexes
*Root Cause:*  
Lack of proper indexes leads to full table scans and slow queries.  

*Remediation:*  
Analyze query patterns and add missing indexes. Use covering indexes where applicable.  

== ğŸ“Š Inaccurate or Missing Statistics
*Root Cause:*  
Outdated or missing stats cause poor cardinality estimates and bad plans.  

*Remediation:*  
Update statistics regularly with AUTO_UPDATE_STATISTICS or scheduled jobs.  

== ğŸ“ Bad T-SQL
*Root Cause:*  
Poorly written SQL (SELECT *, unnecessary joins) increases workload.  

*Remediation:*  
Refactor queries: avoid SELECT *, use explicit columns, optimize joins.  

== ğŸ”„ Problematic Execution Plans
*Root Cause:*  
Inefficient plans due to parameter sniffing or outdated stats.  

*Remediation:*  
Review execution plans, use OPTIMIZE FOR, or parameterize queries properly.  

== ğŸ”’ Excessive Blocking
*Root Cause:*  
Long transactions and locking cause blocked processes.  

*Remediation:*  
Break long transactions, use proper isolation levels, and monitor blocking sessions.  

== âš”ï¸ Deadlocks
*Root Cause:*  
Competing transactions acquire locks in different orders.  

*Remediation:*  
Use TRY/CATCH with retry logic, ensure consistent access order, and optimize indexing.  

== ğŸ” Non-Set-Based Operations
*Root Cause:*  
Row-by-row processing (RBAR) causes poor performance.  

*Remediation:*  
Rewrite cursors and loops as set-based operations.  

== ğŸ—„ Incorrect Database Design
*Root Cause:*  
Normalization or schema design issues lead to inefficient queries.  

*Remediation:*  
Review schema design, apply normalization or denormalization as needed.  

== â™»ï¸ Poor Execution Plan Reuse
*Root Cause:*  
Ad-hoc queries lead to plan cache bloat and poor reuse.  

*Remediation:*  
Parameterize queries, use stored procedures, and enable forced parameterization.  

== ğŸ”¥ Frequent Recompilation of Queries
*Root Cause:*  
OPTION (RECOMPILE), schema changes, or temp tables force recompiles.  

*Remediation:*  
Minimize recompilations by using stable query patterns and cached plans.  

== ğŸ”„ Frequently Updated Columns in Many Indexes
*Root Cause:*  
Updates to indexed columns cause index maintenance overhead and locking.  

*Remediation:*  
Avoid indexing volatile columns; review and minimize unnecessary indexes.  

== ğŸ“ Columns with NVARCHAR(MAX) or Large Size
*Root Cause:*  
Large columns increase memory use and slow joins/sorts.  

*Remediation:*  
Avoid selecting large columns unless necessary; split large data into separate tables.  

== âœ¨ SELECT *
*Root Cause:*  
Retrieves all columns, increases I/O, and prevents index-only scans.  

*Remediation:*  
Select only needed columns to reduce payload and allow covering indexes.  

== ğŸŒŸ Celebrity Tables with Too Many Rows
*Root Cause:*  
Hotspot tables suffer from locking and latch contention.  

*Remediation:*  
Partition or shard large tables; archive old data to reduce contention.  

== ğŸ“š Index INCLUDE with NVARCHAR(MAX) Columns
*Root Cause:*  
Bloating of non-clustered indexes due to large INCLUDE columns.  

*Remediation:*  
Remove large columns from INCLUDE; consider separate lookup strategies.  

== ğŸ“… Scalar Functions in WHERE Clauses
*Root Cause:*  
Non-SARGable expressions disable index seek and force scans.  

*Remediation:*  
Rewrite queries to avoid functions on indexed columns.  

== ğŸ”‘ Key Lookups Instead of Covering Indexes
*Root Cause:*  
Extra I/O for retrieving missing columns from clustered index.  

*Remediation:*  
Add missing columns to covering index or INCLUDE clause.  

== ğŸ”„ Implicit Conversions in Joins/Filters
*Root Cause:*  
Mismatched data types cause scans and prevent index use.  

*Remediation:*  
Align data types in schema and queries to avoid implicit conversions.  

== ğŸ”— Nested Views (View of View)
*Root Cause:*  
Complex nested views confuse the optimizer and lead to suboptimal plans.  

*Remediation:*  
Flatten views or use CTEs for better optimizer visibility.  

== ğŸ“ Overly Wide Tables
*Root Cause:*  
Fetching wide rows increases I/O and memory footprint.  

*Remediation:*  
Split wide tables into narrow ones or fetch only required columns.  

== ğŸ“Š Outdated Statistics
*Root Cause:*  
Optimizer makes poor cardinality estimates with stale stats.  

*Remediation:*  
Use AUTO_UPDATE_STATISTICS or manual updates.  

== ğŸ”— Excessive Joins Without Supporting Indexes
*Root Cause:*  
Large intermediate results and hash spills to tempdb.  

*Remediation:*  
Add supporting indexes and consider query refactoring.  

== ğŸ“¦ Over-Reliance on Scalar UDFs
*Root Cause:*  
Scalar UDFs are executed row-by-row and slow down queries.  

*Remediation:*  
Replace scalar UDFs with inline table-valued functions (TVFs).  

== ğŸ”¥ Hotspot Updates Causing Latch Contention
*Root Cause:*  
Frequent updates to same pages/rows cause latch waits.  

*Remediation:*  
Use batching, row versioning, or redesign schema to avoid hotspots.  

== ğŸ—‚ Tempdb Contention from Heavy Spills
*Root Cause:*  
Hash joins, sorts, or large temp tables overwhelm tempdb.  

*Remediation:*  
Optimize queries to reduce spills and configure multiple tempdb files.  

== ğŸ“Š Poor Partitioning Strategy
*Root Cause:*  
Skewed partitions lead to unbalanced workload.  

*Remediation:*  
Design partitions with even distribution; monitor partition hotspots.  

== ğŸ”¥ Triggers with Expensive Logic
*Root Cause:*  
Triggers add hidden workload on DML operations.  

*Remediation:*  
Refactor trigger logic or replace with explicit application logic.  

== ğŸ”— Missing Foreign Keys
*Root Cause:*  
Leads to inefficient joins and orphan data issues.  

*Remediation:*  
Add foreign keys and create supporting indexes for join columns.  

== ğŸªœ High Index Fragmentation
*Root Cause:*  
Fragmented indexes degrade scan performance.  

*Remediation:*  
Reorganize/rebuild indexes regularly.  
