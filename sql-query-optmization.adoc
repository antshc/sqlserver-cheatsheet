
= üèÅ Full Optimization Process (Phases)

|===
| Phase | Description

| 1Ô∏è‚É£ Baseline & Monitor
| Establish baseline metrics (CPU, memory, I/O, waits)

| 2Ô∏è‚É£ Query Analysis
| Find expensive queries using DMVs, Query Store, etc.

| 3Ô∏è‚É£ Execution Plan Review
| Analyze execution plans for inefficiencies

| 4Ô∏è‚É£ Index Tuning
| Add missing indexes, remove unused, optimize existing

| 5Ô∏è‚É£ Query Refactoring
| Rewrite queries, apply pagination, avoid SELECT *

| 6Ô∏è‚É£ Testing & Validation
| Test changes against workload to verify performance gain
|===


= 1Ô∏è‚É£ Baseline & Monitor

== üìñ What is Baseline & Monitor?

**Baseline** = A snapshot of your system‚Äôs *normal* performance over time.  
**Monitoring** = Ongoing tracking to spot deviations (bottlenecks, regressions).

You need this phase to:  
* ‚úÖ Understand normal vs abnormal behavior
* ‚úÖ Justify optimizations (data-driven)
* ‚úÖ Track improvements after tuning

---

== ‚úÖ Key Metrics to Baseline

|===
| Metric                  | Why It Matters

| **CPU Usage**           | High CPU = queries or bad parallelism
| **Memory Usage**        | Low memory = paging, poor cache performance
| **Disk I/O**            | High reads/writes = missing indexes, bad queries
| **Wait Stats**          | Shows resource contention bottlenecks
| **Batch Requests/sec**  | Indicates workload throughput
| **Page Life Expectancy**| Low PLE = memory pressure
|===

---

== üöÄ How To Establish Baseline

=== 1Ô∏è‚É£ Use Built-in SQL Server DMVs

==== üî• Wait Statistics (Overall bottlenecks)
[source,sql]
----
SELECT wait_type, 
       wait_time_ms / 1000.0 AS wait_time_sec,
       waiting_tasks_count,
       wait_time_ms / waiting_tasks_count AS avg_wait_ms
FROM sys.dm_os_wait_stats
WHERE wait_type NOT IN (
    'CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK',
    'SLEEP_SYSTEMTASK','SQLTRACE_BUFFER_FLUSH','WAITFOR','LOGMGR_QUEUE',
    'CHECKPOINT_QUEUE','REQUEST_FOR_DEADLOCK_SEARCH','XE_TIMER_EVENT','BROKER_TO_FLUSH'
)
ORDER BY wait_time_ms DESC;
----
üìù *Focus on top waits like `CXPACKET`, `PAGEIOLATCH`, `LCK_M_XX`.*

---

==== üî• CPU, Memory, I/O Overview
[source,sql]
----
SELECT
    (SELECT COUNT(*) FROM sys.dm_exec_requests) AS [Current Requests],
    (SELECT COUNT(*) FROM sys.dm_exec_connections) AS [Current Connections],
    (SELECT total_physical_memory_kb/1024 FROM sys.dm_os_sys_memory) AS [Total Memory MB],
    (SELECT available_physical_memory_kb/1024 FROM sys.dm_os_sys_memory) AS [Available Memory MB],
    (SELECT system_memory_state_desc FROM sys.dm_os_sys_memory) AS [Memory State];
----

---

==== üî• I/O Stats (Top Tables by Reads/Writes)
[source,sql]
----
SELECT TOP 10
    DB_NAME(database_id) AS DatabaseName,
    OBJECT_NAME(object_id, database_id) AS TableName,
    user_seeks + user_scans + user_lookups + user_updates AS AccessCount
FROM sys.dm_db_index_usage_stats
ORDER BY AccessCount DESC;
----

---

=== 2Ô∏è‚É£ Use PerfMon (Performance Monitor)

Track these counters:

|===
| Counter                                   | Object

| % Processor Time                          | Processor(_Total)
| Page Life Expectancy                      | SQLServer:Buffer Manager
| SQL Compilations/sec                      | SQLServer:SQL Statistics
| SQL Re-Compilations/sec                   | SQLServer:SQL Statistics
| Batch Requests/sec                        | SQLServer:SQL Statistics
| Disk Reads/sec, Disk Writes/sec           | PhysicalDisk
|===
üéØ *Goal:* Run for 24‚Äì48 hours to capture real workload.

---

=== 3Ô∏è‚É£ Use Query Store (SQL Server 2016+)

Enable Query Store:
[source,sql]
----
ALTER DATABASE [YourDatabaseName]  
SET QUERY_STORE = ON;
----
Track:
* Top resource-consuming queries over time
* Execution plan regressions

---

=== 4Ô∏è‚É£ Third-Party Tools (Optional)

* ‚úÖ Redgate SQL Monitor ‚Äì live dashboards
* ‚úÖ SolarWinds DPA ‚Äì waits and resource graphs
* ‚úÖ SentryOne ‚Äì deep insights on waits, plans

---

== üìä Example: Baseline Table Template

|===
| Metric                  | Value          | Threshold / Notes

| CPU Usage               | 40‚Äì60% avg     | Alert if >80% for 5 min
| Memory Usage            | 70% of total   | Alert if >90%
| Page Life Expectancy    | 5000+          | Alert if <300
| Disk Queue Length       | <2             | Alert if >2 consistently
| Batch Requests/sec      | 500‚Äì1500       | Watch for big drops
|===

---

== üèÅ Why Baseline?

* ‚úÖ Know what‚Äôs ‚Äúnormal‚Äù
* ‚úÖ Detect regressions after deployments
* ‚úÖ Prove ROI of optimizations

  
= 2Ô∏è‚É£ Query Analysis


  
== ‚úÖ 1. Find Most Expensive Queries

These queries consume the **most CPU, reads, or writes**.

=== üìå Top CPU-Consuming Queries
[source,sql]
----
SELECT TOP 10
    qs.total_worker_time / qs.execution_count AS AvgCPU,
    qs.execution_count,
    qs.total_worker_time,
    qs.total_elapsed_time / qs.execution_count AS AvgElapsedTime,
    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
        ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2)+1) AS QueryText,
    qt.dbid, db.name AS DatabaseName
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
JOIN sys.databases db ON qt.dbid = db.database_id
ORDER BY qs.total_worker_time DESC;
----
üìù *What it shows:* Queries that have consumed the most CPU time in total.

---

== ‚úÖ 2. Find Queries with High I/O (Logical Reads/Writes)

These queries may cause **heavy disk usage**.

=== üìå Top I/O-Intensive Queries
[source,sql]
----
SELECT TOP 10
    qs.total_logical_reads / qs.execution_count AS AvgReads,
    qs.total_logical_writes / qs.execution_count AS AvgWrites,
    qs.execution_count,
    qs.total_logical_reads, qs.total_logical_writes,
    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
        ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2)+1) AS QueryText
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
ORDER BY qs.total_logical_reads DESC;
----
üìù *What it shows:* Queries causing the most logical I/O (buffer pool reads/writes).

---

== ‚úÖ 3. Find Long-Running Queries

Find queries that take **the longest time per execution**.

=== üìå Top Long-Running Queries
[source,sql]
----
SELECT TOP 10
    qs.total_elapsed_time / qs.execution_count AS AvgElapsedTime,
    qs.execution_count,
    qs.total_elapsed_time,
    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
        ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2)+1) AS QueryText
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
ORDER BY AvgElapsedTime DESC;
----
üìù *What it shows:* Queries with highest average execution time.

---

== ‚úÖ 4. Find Most Frequently Executed Queries

These might not be slow individually but can cause load due to high execution count.

=== üìå Most Frequently Executed Queries
[source,sql]
----
SELECT TOP 10
    qs.execution_count,
    qs.total_elapsed_time / qs.execution_count AS AvgElapsedTime,
    qs.total_worker_time / qs.execution_count AS AvgCPU,
    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
        ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2)+1) AS QueryText
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
ORDER BY qs.execution_count DESC;
----
üìù *What it shows:* Queries executed most frequently.

---

== ‚úÖ 5. Check Active Expensive Queries (Live)

For currently running queries that might be problematic.

=== üìå Currently Running Expensive Queries
[source,sql]
----
SELECT
    r.session_id,
    r.status,
    r.start_time,
    r.cpu_time,
    r.logical_reads,
    r.reads, r.writes,
    r.wait_type,
    t.text AS QueryText,
    db.name AS DatabaseName
FROM sys.dm_exec_requests r
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
JOIN sys.databases db ON r.database_id = db.database_id
ORDER BY r.cpu_time DESC;
----
üìù *What it shows:* Active queries ordered by CPU usage.

---

== üöÄ Next Steps After Finding Expensive Queries

- üìä **View Execution Plan**
+
[source,sql]
----
SET STATISTICS IO ON;
SET STATISTICS TIME ON;
----
Or right-click query ‚Üí *Display Actual Execution Plan* in SSMS.

- üî• **Look for:**
  * Missing indexes (check missing index DMVs)
  * Table scans or key lookups
  * High sort operations

- üõ† **Refactor:**
  * Rewrite inefficient queries
  * Add proper indexes
  * Avoid `SELECT *`

---

== üìå Tools That Help

- **SQL Server Management Studio (SSMS)**
  * Query Store: Tracks query performance over time
  * Activity Monitor: Shows current expensive queries
- **Third-Party Tools**
  * SentryOne, SolarWinds DPA, Redgate SQL Monitor

---
